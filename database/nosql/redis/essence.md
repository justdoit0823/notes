
Redis
======

Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.
It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs and geospatial indexes with radius queries. Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.


Feature
=======

Key
---

The keys are binary safe, but with the following rules:

  * long keys are not a good idea, which consume more memory and bandwidth.

  * short keys are often not a good idea, which is less readable.

  * stick with a schema.

  * maximum key size is 512MB.



Data types
-----------

  * Bitmap


  * String


  * List


  * Hash


  * Set


  * Sorted Set


  * HyperLogLog


Read more detail at [data-types-intro](https://redis.io/topics/data-types-intro).


Persistence
===========

A different persistence options:

  * the RDB persistence

  * the AOF persistence

  * the RDB and AOF persistence


RDB
---

### How it works ###

Whenevet the redis server needs to dump the database to disk, the following happends in order:

  * forks a child process(SAVE or BGSAVE).

  * the child process starts to write the dataset to a temporary RDB file.

  * when the child process is done writing the new RDB file, it replaces the old one.

### Advantages ###

  * it's a very compact single file and perfect for backups.

  * it's very good for disaster recovery and easy to be transferred between data centers.

  * maximizes performances.

  * faster restart speed with big datasets than AOF.

### Disadvantages ###

  * it's not good for minimizing the chance of data loss.

  * fork can be time consuming if the dataset is big, and may result the parent instance to stop serving clients for some millisecond.


AOF
---

### How log rewriting works ###

Log rewriting uses the same copy-on-write trick already in use for snapshotting.

  * forks a child process.

  * the child process starts writing the new AOF in a temprary file.

  * the parent process accumulates all the new changes in an in-memory buffer.

  * when the child process is done rewriting the file, the parent process gets a signal, and appends the in-memory buffer at the end of the file generated by the child process.

  * renames the old file into the new one, and starts appending new data into the new file.


### Advantages ###

  * it's much more durable.

  * the log is an append only log, there are no seeks, nor corruption problems.

  * it's able to automatically rewrite the AOF log when it gets too big.

  * the content is easy to understand and parse.


### Disadvantages ###

  * the file is usually bigger.

  * it can be slower than RDB depending on the exact fsync policy.

  * the server may not reproduce exactly the same dataset on reloading due to rare bugs in the log.


Read more detail at [persistence](https://redis.io/topics/persistence).


Replication
===========

At the base of Redis replication there is a very simple to use and configure master-slave replication that allows slave Redis servers to be exact copies of master servers.
The slave will automatically reconnect to the master every time the link breaks, and will attempt to be an exact copy of it regardless of what happens to the master.


Replication mechanism
---------------------

### primitives ###


  * Replication ID

  * Offset


### How it works ###

>When slaves connects to master, they use the PSYNC command in order to send their old master replication ID and the offsets they processed so far.
>This way the master can send just the incremental part needed. However if there is not enough backlog in the master buffers, or if the slave is referring to an history (replication ID) which is no longer known, than a full resynchronization happens.


### situation ###

  * A master and a slave instance are well-connected

The master keeps the slave updated by sending a stream of commands in order to replicate the effects on the dataset happening in the master dataset: client writes, keys expiring or evicted, and so forth.


  * The link between the master and the slave breaks

The slave reconnects and attempts to proceed with a partial resynchronization: it means that it will try to just obtain the part of the stream of commands it missed during the disconnection.


  * A partial resynchronization is not possible

This will involve a more complex process in which the master needs to create a snapshot of all its data, send it to the slave, and then continue sending the stream of commands as the dataset changes.


Replication configuration
-------------------------

### redis.conf ###

```
slaveof 192.168.1.1 6379
```

Or using [slaveof](https://redis.io/commands/slaveof) command instead.


### synchronous replication ###

>Synchronous replication of certain data can be requested by the clients using the WAIT command.
>However WAIT is only able to ensure that there are the specified number of acknowledged copies in the other Redis instances: acknowledged writes can still be lost during a failover for different reasons during a failover or depending on the exact configuration of the Redis persistence.


Replication pitfalls
--------------------

  * Safety of replication when master has persistence turned off

**Avoid restarting automatically.**

  * key leak

**Writable slaves before version 4.0 were incapable of expiring keys with a time to live set.**


Read more detail at [replication](https://redis.io/topics/replication).


Partitioning
==============

Partitioning is the process of splitting your data into multiple Redis instances, so that every instance will only contain a subset of your keys.


Partitioning criteria
----------------------

  * range partitioning

  * hash partitioning

  * consistent hashing


Partitioning implemention
--------------------------

  * Client side partitioning

The clients directly select the right node where to write or read a given key.


  * Proxy assisted partitioning

The proxy will make sure to forward our request to the right Redis instance accordingly to the configured partitioning schema,
and will send the replies back to the client.


  * Query routing

The clients can send your query to a random instance, and the instance will make sure to forward your query to the right node.


Redis partitioning
------------------

  * Redis Cluster

  * Twemproxy

  * Clients supporting consistent hashing


Disadvantages
-------------

  * operations involving multiple keys are usually not supported

  * it's not possible to shard a dataset with a single huge key like a very big sorted set

  * data handling is more complex

  * adding and removing capacity can be complex


Read more detail at [partitioning](https://redis.io/topics/partitioning).


Redis Cluster
================

Feature
-------

  * automatically split your dataset among multiple nodes

  * continue operations when a subset of the nodes are experiencing failures


Data Sharding
-------------

>Redis Cluster does not use consistent hashing, but a different form of sharding where every key is conceptually part of what we call an hash slot.
>
>There are 16384 hash slots in Redis Cluster, and to compute what is the hash slot of a given key, we simply take the CRC16 of the key modulo 16384.
>
>Every node in a Redis Cluster is responsible for a subset of the hash slots.


Read more detail at [cluster-tutorial](https://redis.io/topics/cluster-tutorial).


Reference
=========

  * <https://redis.io/documentation>
